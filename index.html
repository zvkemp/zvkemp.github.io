
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>zvkemp</title>
  <meta name="author" content="Zach Kemp">

  
  <meta name="description" content="This is Part 2 of Binary Search Trees in Ruby. Ruby&rsquo;s native Hash implementation more or less follows the basic Hash table principle, wherein &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zvkemp.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="zvkemp" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">zvkemp</a></h1>
  
</hgroup>

</header>
  
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/28/reimplementing-rubys-hash-using-binary-search-trees/">Reimplementing Ruby&#8217;s Hash Using Binary Search Trees</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-28T08:15:28-07:00" pubdate data-updated="true">Apr 28<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>This is Part 2 of <a href="/blog/2014/04/25/binary-search-trees-in-ruby/">Binary Search Trees in Ruby</a>.</em></p>

<p>Ruby&rsquo;s native Hash implementation more or less follows the basic Hash table principle, wherein keys are hashed
(using <code>Object#hash</code>) and stored in the appropriate &lsquo;buckets&rsquo;. In this exercise, we will look at an alternate implementation
of a hash-like key-value store using binary search trees.</p>

<p>The basic structure of the nodes will be as follows:</p>

<ul>
<li>We will use the existing <code>hash</code> method to generate integer values from objects. These will be the node values.</li>
<li>The key object itself will be stored in the node as a separate property.</li>
<li>The value object will also be stored in the node.</li>
</ul>


<p>The binary tree hash will be a simple drop-in replacement for Ruby&rsquo;s Hash class. It won&rsquo;t have enumerable methods, but
it will have square bracket notation for looking up and storing values, an implementation of <code>fetch</code>, and a <code>default_proc</code> feature.</p>

<h3>1. Retrieving a value</h3>

<p>We will use <a href="https://gist.github.com/zvkemp/11305728">our implementation of the basic binary tree</a> as a starting point (but renaming
the classes). The first major difference will be that the <code>value</code> of the node will no longer be its address in the tree &ndash; instead, we use the
hashed key.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">HashNode</span>
</span><span class='line'>    <span class="kp">attr_reader</span> <span class="ss">:hashed_key</span><span class="p">,</span> <span class="ss">:key</span><span class="p">,</span> <span class="ss">:value</span>
</span><span class='line'>    <span class="kp">attr_accessor</span> <span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@value</span>      <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>    <span class="vi">@key</span>        <span class="o">=</span> <span class="n">key</span>
</span><span class='line'>    <span class="vi">@hashed_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">hash</span>
</span><span class='line'>    <span class="vi">@left</span>       <span class="o">=</span> <span class="no">EmptyHashNode</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>    <span class="vi">@right</span>      <span class="o">=</span> <span class="no">EmptyHashNode</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ideally, we would like to be able to use this as a drop-in replacement for <code>Hash</code>, so next let&rsquo;s implement the square-bracket
notation used to retrieve a value. Also, why not write tests for this?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;minitest/autorun&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">describe</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:HashNode</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:bt_hash</span><span class="p">){</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:HashNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:test</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">specify</span> <span class="p">{</span> <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:test</span><span class="o">].</span><span class="n">must_equal</span> <span class="mi">100</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">HashNode</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span><span class='line'>      <span class="n">lookup</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">hash</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Done! Almost. <code>lookup</code> will be a protected method very similar to the old <code>include?</code> that we used for the basic binary tree. The
square bracket notation will simply be an interface that accepts the raw key, but <code>lookup</code> will work with the hashed key (so
we don&rsquo;t need to run the hashing algorithm for every node we traverse).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">HashNode</span>
</span><span class='line'>    <span class="kp">private</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">hk</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">hashed_key</span> <span class="o">&lt;=&gt;</span> <span class="n">hk</span>
</span><span class='line'>        <span class="k">when</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">left</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">hk</span><span class="p">)</span>
</span><span class='line'>        <span class="k">when</span> <span class="o">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">right</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">hk</span><span class="p">)</span>
</span><span class='line'>        <span class="k">when</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">value</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip;and the test passes. Let&rsquo;s try looking up a key that hasn&rsquo;t been set:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">specify</span> <span class="p">{</span> <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:missing</span><span class="o">].</span><span class="n">must_be_nil</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In order for this test to pass, we will need to traverse the entire tree until we end up at an empty node.
That node should respond to the <code>lookup</code> method with <code>nil</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">EmptyHashNode</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
</span><span class='line'>      <span class="kp">nil</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>2. Storing a value</h3>

<p>So now let&rsquo;s try inserting a key-value pair using the <code>[]=</code> notation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">specify</span> <span class="s2">&quot;inserting a new value&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:hello</span><span class="o">]</span> <span class="o">=</span> <span class="mi">200</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:hello</span><span class="o">].</span><span class="n">must_equal</span> <span class="mi">200</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">specify</span> <span class="s2">&quot;overwriting an existing value&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:test</span><span class="o">]</span> <span class="o">=</span> <span class="mi">101</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:test</span><span class="o">].</span><span class="n">must_equal</span> <span class="mi">101</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Similar to the <code>[]</code> method, we&rsquo;ll implement <code>[]=</code> as an interface to the protected method <code>store</code>, which will accept the
hashed key and raw value:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">HashNode</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="n">store</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are two possibilities here: inserting a new value and overwriting an existing value. Both covered by our two new tests. We
can handle both of these in one <code>store</code> method, but we need to change <code>value</code> from <code>attr_reader</code> to <code>attr_accessor</code> so we
can update its contents:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">HashNode</span>
</span><span class='line'>    <span class="kp">attr_accessor</span> <span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span><span class="p">,</span> <span class="ss">:value</span>
</span><span class='line'>
</span><span class='line'>    <span class="kp">protected</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">hashed_key</span> <span class="o">&lt;=&gt;</span> <span class="n">hk</span>
</span><span class='line'>        <span class="k">when</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">store_left</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">when</span> <span class="o">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">store_right</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">when</span> <span class="mi">0</span> <span class="k">then</span> <span class="nb">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">#...</span>
</span></code></pre></td></tr></table></div></figure>


<p>But now we have a problem &ndash; we&rsquo;ve been passing the hashed key down the tree looking for the correct place to store it,
but when we get there, we don&rsquo;t have the original key to pass to the constructor of <code>HashNode</code>. In fact, we don&rsquo;t even really
need it, because all lookups and stores operate on the hashed value anyway, but if we want to be able to inspect the tree,
it would be nice to see the keys we&rsquo;ve assumed we were using. It&rsquo;s not the nicest looking solution, but since we&rsquo;re
operating with protected methods, I&rsquo;m not very concerned about simply tacking another argument onto the end of <code>store</code>, <code>store_left</code>, and <code>store_right</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># ...</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>    <span class="n">store</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="kp">protected</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">hashed_key</span> <span class="o">&lt;=&gt;</span> <span class="n">hk</span>
</span><span class='line'>    <span class="k">when</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">store_left</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>    <span class="k">when</span> <span class="o">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">store_right</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>    <span class="k">when</span> <span class="mi">0</span> <span class="k">then</span> <span class="nb">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">store_left</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>    <span class="n">left</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="no">HashNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">store_right</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>    <span class="n">right</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="no">HashNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># ...</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. Fetch</h3>

<p>Ok! We&rsquo;re actually almost done. Let&rsquo;s add a whole slew of tests and see how well this conforms to Ruby&rsquo;s native Hash implementation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">specify</span> <span class="s2">&quot;storing arbitrary objects as keys&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">obj</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="n">obj</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1001</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="n">obj</span><span class="o">].</span><span class="n">must_equal</span> <span class="mi">1001</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">specify</span> <span class="s2">&quot;nesting hashes&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">other_hash</span> <span class="o">=</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:HashNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:world</span><span class="p">,</span> <span class="mi">102</span><span class="p">)</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:hello</span><span class="o">]</span> <span class="o">=</span> <span class="n">other_hash</span>
</span><span class='line'>  <span class="n">bt_hash</span><span class="o">[</span><span class="ss">:hello</span><span class="o">][</span><span class="ss">:world</span><span class="o">].</span><span class="n">must_equal</span> <span class="mi">102</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both of these tests pass without any further modifications to the <code>HashNode</code>. However, these:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">specify</span> <span class="p">{</span> <span class="n">bt_hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:test</span><span class="p">)</span><span class="o">.</span><span class="n">must_equal</span> <span class="mi">100</span> <span class="p">}</span>
</span><span class='line'><span class="n">specify</span> <span class="p">{</span> <span class="n">bt_hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:missing</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span><span class="o">.</span><span class="n">must_equal</span> <span class="mi">101</span> <span class="p">}</span>
</span><span class='line'><span class="n">specify</span> <span class="p">{</span> <span class="o">-&gt;</span><span class="p">{</span> <span class="n">bt_hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:missing</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="n">must_raise</span> <span class="no">KeyError</span> <span class="p">}</span>
</span><span class='line'><span class="n">specify</span> <span class="p">{</span> <span class="n">bt_hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:missing</span><span class="p">)</span> <span class="p">{</span> <span class="mi">101</span> <span class="p">}</span><span class="o">.</span><span class="n">must_equal</span> <span class="mi">101</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip;use the powerful <code>fetch</code> method, which we have not implemented. <code>fetch</code> provides several ways of handling missing values in a hash:
specifying a default missing value, returning a value from a block, or raising a <code>KeyError</code>. On its face, <code>fetch</code> is a modified version
of the <code>lookup</code> method, implemented as a series of guard clauses:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#...</span>
</span><span class='line'><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>  <span class="n">v</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">v</span> <span class="k">if</span> <span class="n">v</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">default</span> <span class="k">if</span> <span class="n">default</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span> <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'>  <span class="k">raise</span> <span class="no">KeyError</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1">#...</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip; and the tests pass.</p>

<h3>4. <code>default_proc</code></h3>

<p>The last hash feature I use regularly is called the <code>default_proc</code>, which stores a block that is called when a given key is
not present in the hash table. It is used like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="o">|</span> <span class="nb">hash</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span> <span class="p">}</span>
</span><span class='line'><span class="nb">hash</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="c1">#=&gt; { 0 =&gt; [1, 2, 3] }</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since our binary tree hash is a distributed recursive data structure, at first glance this presents a special challenge &mdash;
each node will need to store the default proc and pass it on to new node instances as they are created. But that&rsquo;s not actually true.
The recursive nature of the structure means that lookups bubble up through the tree and are returned through the root node&rsquo;s lookup function,
meaning the proc only has to be stored at the root.</p>

<p>Let&rsquo;s start with some tests. Our hash will automatically fire up some arrays for us when a new key is given:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span><span class="p">(</span><span class="ss">:defaulting_hash</span><span class="p">){</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:HashNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:test</span><span class="p">,</span> <span class="o">[]</span><span class="p">){</span><span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="o">|</span> <span class="nb">hash</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span><span class="p">}</span> <span class="p">}</span>
</span><span class='line'><span class="n">specify</span> <span class="p">{</span> <span class="n">defaulting_hash</span><span class="o">[</span><span class="ss">:empty</span><span class="o">].</span><span class="n">must_equal</span> <span class="o">[]</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">specify</span> <span class="s2">&quot;inserting values&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">defaulting_hash</span><span class="o">[</span><span class="ss">:my_array</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
</span><span class='line'>  <span class="n">defaulting_hash</span><span class="o">[</span><span class="ss">:my_array</span><span class="o">].</span><span class="n">must_equal</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>In Ruby&rsquo;s hash implementation, the default proc is only called for <code>[]</code> lookups &mdash; <code>fetch</code> still works the same way regardless of the presence
of the constructor block. In addition to altering <code>[]</code>, We need to modify <code>initialize</code> and add a new accessor for <code>default_proc</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">HashNode</span>
</span><span class='line'>    <span class="kp">attr_reader</span> <span class="ss">:default_proc</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">default_proc</span><span class="p">)</span>
</span><span class='line'>      <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>      <span class="vi">@key</span> <span class="o">=</span> <span class="n">key</span>
</span><span class='line'>      <span class="vi">@hashed_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">hash</span>
</span><span class='line'>      <span class="vi">@left</span> <span class="o">=</span> <span class="no">EmptyHashNode</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>      <span class="vi">@right</span> <span class="o">=</span> <span class="no">EmptyHashNode</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>      <span class="vi">@default_proc</span> <span class="o">=</span> <span class="n">default_proc</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span><span class='line'>      <span class="n">v</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">hash</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">v</span> <span class="k">if</span> <span class="n">v</span>
</span><span class='line'>      <span class="n">default_proc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">default_proc</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The block passed to <code>Hash#new</code> uses the hash and a key as formal arguments, so we can simply call the proc using the current
node and the given k. The recursive structure of the binary tree will take care of the rest:</p>

<pre><code>my_hash = BinaryTree::HashNode.new(:test, 100){|hash, key| hash[key] = 100 }
my_hash[:my_array] &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3
# =&gt; {test =&gt; []:{my_array =&gt; [1, 2, 3]:{}|{}}|{}}
</code></pre>

<h3>Appendix</h3>

<p>Here is the complete source code for the binary tree hash:</p>

<div><script src='https://gist.github.com/11378255.js'></script>
<noscript><pre><code>module BinaryTree
  class EmptyHashNode
    def to_a
      []
    end

    def inspect
      &quot;{}&quot;
    end

    def lookup(*)
      nil
    end

    def store(*)
      false
    end
  end

  class HashNode
    # our three features:
    attr_reader :hashed_key, :key, :default_proc
    attr_accessor :left, :right, :value

    def initialize(key, value, &amp;block)
      @value      = value
      @key        = key
      @hashed_key = key.hash
      @left       = EmptyHashNode.new
      @right      = EmptyHashNode.new
      @default_proc = block
    end

    def [](k)
      v = lookup(k.hash)
      return v if v
      default_proc.call(self, k) if default_proc
    end

    def fetch(k, default = nil, &amp;block)
      v = lookup(k.hash) 
      return v if v
      return default if default
      return block.call if block_given?
      raise KeyError
    end

    def []=(k, v)
      store(k.hash, v, k)
    end

    def inspect
      &quot;{#{key} =&gt; #{value}:#{left.inspect}|#{right.inspect}}&quot;
    end

    protected

      def lookup(hk)
        case hashed_key &lt;=&gt; hk
        when 1 then left.lookup(hk)
        when -1 then right.lookup(hk)
        when 0 then value
        end
      end

      def store(hk, v, k)
        case hashed_key &lt;=&gt; hk
        when 1 then store_left(hk, v, k)
        when -1 then store_right(hk, v, k)
        when 0 then self.value = v
        end
      end

    private

      def store_left(hk, v, k)
        left.store(hk, v, k) or self.left = HashNode.new(k, v)
      end

      def store_right(hk, v, k)
        right.store(hk, v, k) or self.right = HashNode.new(k, v)
      end

      def left=(v)
        @left = v
      end

      def right=(v)
        @right = v
      end
  end
end

</code></pre></noscript></div>


<p>And the tests:</p>

<div><script src='https://gist.github.com/11378213.js'></script>
<noscript><pre><code>
require &#39;minitest/autorun&#39;
require &#39;minitest/pride&#39;

describe BinaryTree::HashNode do
  let(:bt_hash){ BinaryTree::HashNode.new(:test, 100) }
  specify { bt_hash[:test].must_equal 100 }
  specify { bt_hash[:missing].must_be_nil }

  specify &quot;inserting a new value&quot; do
    bt_hash[:hello] = 200
    bt_hash[:hello].must_equal 200
  end

  specify &quot;overwriting an existing value&quot; do
    bt_hash[:test] = 101
    bt_hash[:test].must_equal 101
  end

  specify &quot;storing arbitrary objects as keys&quot; do
    obj = Object.new
    bt_hash[obj] = 1001
    bt_hash[obj].must_equal 1001
  end

  specify &quot;nesting hashes&quot; do
    other_hash = BinaryTree::HashNode.new(:world, 102)
    bt_hash[:hello] = other_hash
    bt_hash[:hello][:world].must_equal 102
  end

  specify { bt_hash.fetch(:test).must_equal 100 }
  specify { bt_hash.fetch(:missing, 101).must_equal 101 }
  specify { -&gt;{ bt_hash.fetch(:missing) }.must_raise KeyError }
  specify { bt_hash.fetch(:missing) { 101 }.must_equal 101 }


  let(:defaulting_hash){ BinaryTree::HashNode.new(:test, []){|hash, key| hash[key] = []} }
  specify { defaulting_hash[:empty].must_equal [] }

  specify &quot;inserting values&quot; do
    defaulting_hash[:my_array] &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3
    defaulting_hash[:my_array].must_equal [1, 2, 3]
  end
end
</code></pre></noscript></div>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/25/binary-search-trees-in-ruby/">Binary Search Trees in Ruby</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-25T10:16:18-07:00" pubdate data-updated="true">Apr 25<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In learning about Haskell recently, I was introduced to a recursive data structure I had never used before (at least not knowingly) &ndash; the binary search tree (BST). The BST is made up of nodes that have three main features:</p>

<ol>
<li>They contain a value</li>
<li>They can refer to another node to the left with a smaller value</li>
<li>They can refer to another node to the right with a larger value</li>
</ol>


<p>So let&rsquo;s throw a simple problem at this: determining whether a given integer is a member of an array.</p>

<p>Can we construct a binary search tree in Ruby that is faster than Ruby&rsquo;s native C-implemented Array class? (Spoilers: <em>yes.</em>)</p>

<h2>1. Implementation</h2>

<p><em>My first implementation of this had an overarching <code>Tree</code> class, but it soon became clear that it&rsquo;s entirely unccessary. As a recursive data structure, each node has a tree descending from it, so we just need a <code>Node</code>. The tree will be implied.</em></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>    <span class="c1"># our three features:</span>
</span><span class='line'>    <span class="kp">attr_reader</span> <span class="ss">:value</span>
</span><span class='line'>    <span class="kp">attr_accessor</span> <span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="vi">@value</span> <span class="o">=</span> <span class="n">v</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">tree</span>       <span class="o">=</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">tree</span><span class="o">.</span><span class="n">left</span>  <span class="o">=</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="n">tree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">tree</span><span class="o">.</span><span class="n">inspect</span>
</span><span class='line'><span class="c1">#&lt;BinaryTree::Node:0x007f9ce207a770 @value=10, </span>
</span><span class='line'><span class="c1"># @left=#&lt;BinaryTree::Node:0x007f9ce207a748 @value=5&gt;, </span>
</span><span class='line'><span class="c1"># @right=#&lt;BinaryTree::Node:0x007f9ce207a720 @value=15&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Great! But also: awful. Instead of constructing the tree manually, we need to be able to treat it
as if it were an array. We should be able to apply the shovel operator to the base node of the tree
and have the tree place the value wherever it should rightfully or leftfully go.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">value</span> <span class="o">&lt;=&gt;</span> <span class="n">v</span>
</span><span class='line'>      <span class="k">when</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">left</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">when</span> <span class="o">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">right</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">when</span> <span class="mi">0</span> <span class="k">then</span> <span class="kp">false</span> <span class="c1"># the value is already present</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This uses Ruby&rsquo;s spaceshipesque comparator <code>&lt;=&gt;</code> to determine if the value to be inserted is greater than, less than, or equal to the value of the current node, and then traverses the tree until &hellip;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; binary_tree.rb:13:in `insert&#39;: undefined method `insert&#39; for nil:NilClass (NoMethodError)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Spectacular! Except: not. We have a node that expected its left value to respond to <code>insert</code>, to which <code>nil</code> annoyingly refused. We can redefine more specific insert methods to work around this issue (and, since it&rsquo;s getting a bit hard to read, a new <code>inspect</code> method):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">value</span> <span class="o">&lt;=&gt;</span> <span class="n">v</span>
</span><span class='line'>      <span class="k">when</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">insert_left</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">when</span> <span class="o">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">insert_right</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">when</span> <span class="mi">0</span> <span class="k">then</span> <span class="kp">false</span> <span class="c1"># the value is already present</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">inspect</span>
</span><span class='line'>      <span class="s2">&quot;{</span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">::</span><span class="si">#{</span><span class="n">left</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">|</span><span class="si">#{</span><span class="n">right</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">}&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="nf">insert_left</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">left</span>
</span><span class='line'>          <span class="n">left</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>          <span class="nb">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="no">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="nf">insert_right</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">right</span>
</span><span class='line'>          <span class="n">right</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>          <span class="nb">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="no">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; {10:{5:{3:nil|nil}|nil}|{15:nil|nil}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The next step is to determine whether our tree contains a given value.
This is where the Binary Search Tree has a reputation for speediness &ndash; unlike
iterating over every element of an array and checking for equality, the structure of the
tree provides a sort of automatic index that points us to where the value <em>should</em> be,
and then we can check if it&rsquo;s there. It&rsquo;ll look remarkably similar to our <code>insert</code> method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># named include? to parallel Array#include?</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">include?</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">value</span> <span class="o">&lt;=&gt;</span> <span class="n">v</span>
</span><span class='line'>      <span class="k">when</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">left</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">when</span> <span class="o">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">right</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">when</span> <span class="mi">0</span> <span class="k">then</span> <span class="kp">true</span> <span class="c1"># the current node is equal to the value</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you were paying attention to the <code>insert</code> method, you can probably guess that when this  method reaches a <code>left</code> or <code>right</code> that is <code>nil</code>, it will fail. Which is <em>really annoying!</em> But since this seems to be a pattern we have stumbled upon, let&rsquo;s find a better way to solve this rather than peppering the code with nil checks. Enter our second class, <code>EmptyNode</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">EmptyNode</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">include?</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
</span><span class='line'>      <span class="kp">false</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
</span><span class='line'>      <span class="kp">false</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">inspect</span>
</span><span class='line'>      <span class="s2">&quot;{}&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip;and make sure instances of this class terminate our tree by default:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">EmptyNode</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="vi">@value</span> <span class="o">=</span> <span class="n">v</span>
</span><span class='line'>      <span class="vi">@left</span>  <span class="o">=</span> <span class="no">EmptyNode</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>      <span class="vi">@right</span> <span class="o">=</span> <span class="no">EmptyNode</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">happy</span> <span class="o">=</span> <span class="no">BinaryTree</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">left</span> <span class="c1">#=&gt; </span>
</span></code></pre></td></tr></table></div></figure>


<p><em>Note: the <code>(*)</code> formal argument to these <code>EmptyNode</code>&rsquo;s methods simply states that we don&rsquo;t
care how many arguments are passed to the method, and that we won&rsquo;t be using them anyway.</em></p>

<p>The <code>EmptyNode</code> class is useful in that it provides a meaningful end to the recursive
structure &mdash; specifically, that a given range of values in the tree are definitively
not present. Otherwise, it does very little. We don&rsquo;t allow <code>insert</code> to do anything with it,
because then it wouldn&rsquo;t be an empty node.  Unfortunately, we can&rsquo;t simply tell it to replace itself
with a <code>Node</code> object (as that isn&rsquo;t possible in Ruby), so we have to change the reference back at the parent node:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>    <span class="kp">private</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">insert_left</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="n">left</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="no">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="nf">insert_right</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="n">right</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="no">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, we use the <code>or</code> control flow operator to perform one of two actions: if the first returns
a falsey value, the second (assign the new <code>Node</code> object).</p>

<p>Ok! So we now have a binary tree that can insert new values at the correct location
and tell you whether or not it contains a given value. Let&rsquo;s check it out:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">tree</span> <span class="o">=</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>               <span class="c1">#=&gt; {10:{}|{}}</span>
</span><span class='line'><span class="o">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="o">].</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span> <span class="c1">#=&gt; {10:{5:{3:{}|{}}|{}}|{15:{}|{}}}</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1">#=&gt; false</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">#=&gt; false</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2. Benchmarks</h2>

<p>Let&rsquo;s benchmark it! This test populates an array with 5000 random values up to 50,000, that checks every value between
1 and 50,000 to see if the array includes it. The same benchmark is repeated for the binary tree containing an
identical set of values.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;benchmark&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">test_array</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="mi">5000</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="n">test_array</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nb">rand</span> <span class="mi">50000</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">tree</span> <span class="o">=</span> <span class="ss">BinaryTree</span><span class="p">:</span><span class="ss">:Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">test_array</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
</span><span class='line'><span class="n">test_array</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">benchmark</span><span class="o">|</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;test_array include&quot;</span><span class="p">){</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">test_array</span><span class="o">.</span><span class="n">include?</span> <span class="n">n</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;binary tree search&quot;</span><span class="p">){</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span> <span class="n">n</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>                        user     system      total        real
test_array include 13.230000   0.020000  13.250000 ( 13.283172)
binary tree search  0.140000   0.000000   0.140000 (  0.139983)
</code></pre>

<p>I have to say, I was a little surprised how much faster (~100x) this was. It makes sense when you think about the fact that
to check if an element is included in the Array, Ruby needs to run an equality comparison for up to 5000 values 50000 times.
That&rsquo;s a lot of overhead, and Arrays simply aren&rsquo;t optimized for this. Ruby has another built-in data structure that is
explicitly designed for fast lookups of arbitrary values &mdash; the venerable <code>Hash</code>.
Similar to a binary search tree, Ruby&rsquo;s hash tables follow a defined set of rules that guide it to the
proper places in memory when setting and retrieving values. For an in-depth exploration of what makes Hashes fast, read Pat Shaughnessy&rsquo;s <em><a href="http://www.worldcat.org/title/ruby-under-a-microscope-an-illustrated-guide-to-ruby-internals/oclc/844728904&amp;referer=brief_results">Ruby Under a Microscope</a>.</em></p>

<p>Let&rsquo;s rerun the benchmark again, but this time comparing hash lookups as well. For these purposes, it doesn&rsquo;t matter what the values
are in the hash, so we&rsquo;ll just make them all <code>true</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">test_hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">[</span><span class="n">test_array</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">[</span><span class="n">x</span><span class="p">,</span> <span class="kp">true</span><span class="o">]</span> <span class="p">}</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">benchmark</span><span class="o">|</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;test_array include&quot;</span><span class="p">){</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">test_array</span><span class="o">.</span><span class="n">include?</span> <span class="n">n</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;binary tree search&quot;</span><span class="p">){</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span> <span class="n">n</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;test_hash lookup&quot;</span>  <span class="p">){</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="nb">hash</span><span class="o">.</span><span class="n">has_key?</span> <span class="n">n</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>                         user     system      total        real
 test_array include 13.400000   0.020000  13.420000 ( 13.473588)
 binary tree search  0.130000   0.000000   0.130000 (  0.129013)
 test_hash lookup    0.000000   0.000000   0.000000 (  0.008119)
</code></pre>

<p>Ruby&rsquo;s native C-implemented Hash is around 15 times faster than the Ruby-implemented binary search tree, which is about what I expected.</p>

<h2>3. Array Conversions</h2>

<p>In order to convert arrays into binary trees and back again, let&rsquo;s introduce a few new methods. The first will be a module method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">from_array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span><span class='line'>    <span class="no">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">first</span><span class="p">)</span><span class="o">.</span><span class="n">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">tree</span><span class="o">|</span>
</span><span class='line'>      <span class="n">array</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">tree</span><span class="o">.</span><span class="n">insert</span> <span class="n">v</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>from_array</code> simply assigns the root node of the tree as the first value of the array, then pushes
all array values on in order. Converting back to an array is a simple matter of traversing the recursive tree.
An interesting side effect is that if done in a particular way, this is equivalent to calling <code>.uniq.sort</code> on the original array (as far as I know,
it&rsquo;s impossible to maintain the original order).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">BinaryTree</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">to_a</span>
</span><span class='line'>      <span class="n">left</span><span class="o">.</span><span class="n">to_a</span> <span class="o">+</span> <span class="o">[</span><span class="n">value</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">to_a</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">class</span> <span class="nc">EmptyNode</span>
</span><span class='line'>    <span class="c1"># unsurprisingly, an empty node returns an empty array</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">to_a</span>
</span><span class='line'>      <span class="o">[]</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>In case it&rsquo;s not clear how the recursion works, here&rsquo;s what the array expansion looks like for a simple tree <code>{10:{5:{}|{}}|{15:{}|{}}}</code>:</p>

<ol>
<li>For both 5 and 15, <code>left.to_a</code> and <code>right.to_a</code> are <code>[]</code> (<code>EmptyNode#to_a</code>), so the results are <code>[5]</code> and <code>[15]</code> respectively</li>
<li>For 10, <code>left.to_a</code> is <code>[5]</code> and <code>right.to_a</code> is <code>[15]</code>, giving <code>[5] + [10] + [15]</code> or <code>[5, 10, 15]</code></li>
</ol>


<p>We can test it on an example with more elements:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">array</span> <span class="o">=</span> <span class="o">[</span><span class="mi">51</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">91</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">34</span><span class="o">]</span>
</span><span class='line'><span class="n">tree</span> <span class="o">=</span> <span class="no">Binary</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; {51:{4:{}|{34:{}|{}}}|{88:{62:{}|{68:{67:{}|{}}|{}}}|{98:{93:{91:{}|{}}|{}}|{}}}}</span>
</span><span class='line'><span class="n">tree</span><span class="o">.</span><span class="n">to_a</span> <span class="c1">#=&gt; [4, 34, 51, 62, 67, 68, 88, 91, 93, 98]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Interestingly, it&rsquo;s faster to convert a large array into a binary tree and perform a search than it is to call <code>include?</code> on the Array.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">array</span> <span class="o">=</span> <span class="mi">5000</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nb">rand</span> <span class="mi">50000</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">benchmark</span><span class="o">|</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;array#include?&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">array</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">}}</span>
</span><span class='line'>  <span class="n">benchmark</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;binary search&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">tree</span> <span class="o">=</span> <span class="no">BinaryTree</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">50000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">tree</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>                    user     system      total        real
array#include? 13.160000   0.020000  13.180000 ( 13.235368)
binary search   0.190000   0.000000   0.190000 (  0.188989)
</code></pre>

<p>It takes about 50% longer than just the binary tree search itself, which makes sense because it
traverses the tree twice (once to insert values and once to query them). It doesn&rsquo;t take twice as long,
because we start with a small tree (a single node) and build it up gradually as the values are inserted.</p>

<h2>4. Why would I use this?</h2>

<p>Because of nerdliness?</p>

<p>Honestly cannot think of an instance where this would have been useful to me in a Ruby project, including
those where I&rsquo;m juggling querying enormous quantities of data.</p>

<p>As much as we are loathe to admit it, there <em>are other languages</em> that <em>behave differently from Ruby</em>
and are <em>used for different things</em>. <a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees">Here&rsquo;s a StackOverflow question describing some of them</a>.</p>

<p><em>Check back next week for a discussion of balanced binary search trees!</em></p>

<h2>Appendix</h2>

<p>Here is the code in its entirety:</p>

<div><script src='https://gist.github.com/11305728.js'></script>
<noscript><pre><code># https://zvkemp.github.io/blog/2014/04/25/binary-search-trees-in-ruby/

module BinaryTree
  class EmptyNode
    def to_a
      []
    end

    def include?(*)
      false
    end

    def push(*)
      false
    end
    alias_method :&lt;&lt;, :push

    def inspect
      &quot;{}&quot;
    end
  end

  class Node
    # our three features:
    attr_reader :value
    attr_accessor :left, :right

    def initialize(v)
      @value = v
      @left = EmptyNode.new
      @right = EmptyNode.new
    end

    def push(v)
      case value &lt;=&gt; v
      when 1 then push_left(v)
      when -1 then push_right(v)
      when 0 then false # the value is already present
      end
    end
    alias_method :&lt;&lt;, :push

    def include?(v)
      case value &lt;=&gt; v
      when 1 then left.include?(v)
      when -1 then right.include?(v)
      when 0 then true # the current node is equal to the value
      end
    end

    def inspect
      &quot;{#{value}:#{left.inspect}|#{right.inspect}}&quot;
    end

    def to_a
      left.to_a + [value] + right.to_a
    end

    private

      def push_left(v)
        left.push(v) or self.left = Node.new(v)
      end

      def push_right(v)
        right.push(v) or self.right = Node.new(v)
      end
  end
end
</code></pre></noscript></div>



</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p>Zach Kemp</p>
  <p>GitHub: <a href="https://github.com/zvkemp">zvkemp</a></p>
  <p>Gmail: zvkemp@gmail.com</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/04/28/reimplementing-rubys-hash-using-binary-search-trees/">Reimplementing Ruby&#8217;s Hash Using Binary Search Trees</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/25/binary-search-trees-in-ruby/">Binary Search Trees in Ruby</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Zach Kemp -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
